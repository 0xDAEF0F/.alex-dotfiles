{"id":"a781f384-d422-4e9a-aac5-0731da3cc178","zed":"context","version":"0.4.0","text":"\n\n\n```ts crawlee-py/src/types.ts:4-21\n// Excerpt from: \nexport const jobSchema = z\n  .object({\n    title: z.string().min(5).max(100),\n    job_url: z.string().url(),\n    company: z.string().min(3).max(100),\n    tags: z.array(z.string().min(3)),\n    date: z.string().datetime({ local: true }),\n    job_description: z.string().min(10),\n    real_job_url: z.string().url(),\n  })\n  .transform((data) => {\n    const transformed: Record<string, unknown> = {};\n    Object.entries(data).forEach(([key, value]) => {\n      transformed[snakeToCamel(key)] = value;\n    });\n    return transformed;\n  });\n\n```\nlets properly type this jobSchema so that typescript knows the\nkeys/values\nHere's how we can properly type the jobSchema by defining an interface for both the input and output types:\n\n```typescript\n// Input type before transformation\ninterface JobInput {\n  title: string;\n  job_url: string;\n  company: string;\n  tags: string[];\n  date: string;\n  job_description: string;\n  real_job_url: string;\n}\n\n// Output type after transformation (camelCase)\ninterface JobOutput {\n  title: string;\n  jobUrl: string;\n  company: string;\n  tags: string[];\n  date: string;\n  jobDescription: string;\n  realJobUrl: string;\n}\n\nexport const jobSchema = z\n  .object({\n    title: z.string().min(5).max(100),\n    job_url: z.string().url(),\n    company: z.string().min(3).max(100),\n    tags: z.array(z.string().min(3)),\n    date: z.string().datetime({ local: true }),\n    job_description: z.string().min(10),\n    real_job_url: z.string().url(),\n  })\n  .transform((data: JobInput): JobOutput => {\n    const transformed: Record<string, unknown> = {};\n    Object.entries(data).forEach(([key, value]) => {\n      transformed[snakeToCamel(key)] = value;\n    });\n    return transformed as JobOutput;\n  });\n\n// You can then use these types when working with the schema\nexport type Job = z.infer<typeof jobSchema>;\n```\n\nThis provides several benefits:\n\n1. `JobInput` defines the shape of the data before transformation (snake_case)\n2. `JobOutput` defines the shape after transformation (camelCase)\n3. The transform function is properly typed with input and output types\n4. `Job` type can be exported and used elsewhere in your code\n5. TypeScript will provide better autocomplete and type checking\n\nYou can then use it like this:\n\n```typescript\n// TypeScript knows this is type Job (JobOutput)\nconst job = jobSchema.parse({\n  title: \"Software Engineer\",\n  job_url: \"https://example.com/job\",\n  company: \"Example Corp\",\n  tags: [\"typescript\", \"javascript\"],\n  date: \"2024-01-01T12:00:00\",\n  job_description: \"A great job opportunity\",\n  real_job_url: \"https://example.com/real-job\"\n});\n\n// TypeScript knows all these properties exist and are properly typed\nconsole.log(job.jobUrl);\nconsole.log(job.jobDescription);\n```\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":167}}},{"id":{"replica_id":0,"value":55},"start":669,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":168}}},{"id":{"replica_id":0,"value":56},"start":2777,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":169}}}],"summary":"TypeScript Job Schema Type Definition","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":593},"icon":"TextSnippet","label":"crawlee-py/src/types.ts, Lines 4 to 21","metadata":null}]}